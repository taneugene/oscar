import pandas as pd
import numpy as np
from os.path import exists

# Some simple string ops and formatting handling
def replace_unnamed(s):
    """string op to replace 'nan' strings and "Unnamed" strings with null values"""
    if 'Unnamed' in s:
        return np.nan
    elif 'nan' == s:
        return np.nan
    else:
        return s
def replace_line_breaks(s):
    if type(s) != str:
        return s
    if '\n' in s:
        n = s.index('\n')
        return s[:n] + ' ' + s[n+1:]
    else:
        return s




# Vulnerability function
def vulnerability(hazard, method='depth', reg= 'sa'):
    """Applies a vulnerability function to an array. Returns an array of
    imputed damages as a % of assets"""
    # Assume all people that get flooded are damaged completely
    if method == 'depth':
        # Returns a % damage map based on EU data
        fd = flood_damage(reg)
        # Change nans to 0
        hazard = np.nan_to_num(hazard)
        # Fast way to vectorize a sorted lookup (as opposed to a dictionary lookup)
        indices = np.searchsorted(fd.index, hazard, side='right') - 1
        damage = fd.values[indices]
    elif method == 'boolean':
        damage = hazard.astype(bool)
    else:
        raise AssertionError('vulnerability function not specified correctly')
    return damage
    

cleaned_fname = './data/vulnerabilities/cleaned_damage_functions.csv'
# If this is being run as it's own script (not an import or if the cleaned_fname
# does not exist) then create the file
if (not exists(cleaned_fname)) or (__name__ == '__main__'):
    # get data
    df = pd.read_excel('./data/vulnerabilities/copy_of_global_flood_depth-damage_functions__30102017.xlsx', sheet_name='Damage functions')
    # fill merged cells
    df[df.columns[0]] = df[df.columns[0]].fillna(method = 'ffill')
    # apply above functions and organize columns
    df.columns = pd.Series(df.columns).apply(replace_unnamed).apply(replace_line_breaks).fillna(method='ffill')
    df = df.set_index(list(df.columns[:2]))
    loc = df.iloc[0].astype(str).apply(lambda s: s.lower()).apply(replace_line_breaks).apply(replace_unnamed)
    df.columns = pd.MultiIndex.from_tuples(list(zip(df.columns,loc)))
    # now drop the old country names (not in column index)
    df = df.drop(df.iloc[0].name)
    # clean up null values to np format
    df = df.replace('-', np.nan)
    # save to file
    df.to_csv(cleaned_fname)

region_dic = {'eu': 'europe',
              'na': 'north america',
              'sa': 'centr&south america',
              'as': 'asia',
              'af': 'africa',
              'oc': 'oceania',
              'gl': 'global'
              }

def damage_function(reg = 'global'):
    # Read csv with multiindices
    try:
        df = pd.read_csv(cleaned_fname, index_col = [0,1], header = [0,1])
    except:
        raise AssertionError('Check that the file {} is correct'.format(cleaned_fname))
    # Use shortcuts from region dic to get a column name.
    try:
        if len(reg) == 2:
            reg = region_dic[reg]
        # locate damage functions for the selected region
        damages =  df['Damage function', reg]
        damages = damages.dropna().mean(level=1)
        # SSBN max value is 10m
        keys = np.arange(0,10.1,0.1)
        return pd.Series(np.interp(keys, damages.index, damages.values), index = keys)
    except:
        raise AssertionError('choose a region from the following: {}'.format(region_dic))
